import { createPublicClient, createWalletClient, http } from '@arkiv-network/sdk';
import { privateKeyToAccount } from '@arkiv-network/sdk/accounts';
import { mendoza } from '@arkiv-network/sdk/chains';
import { ExpirationTime, jsonToPayload } from '@arkiv-network/sdk/utils';
import type { Address, WalletClient } from 'viem';

// Mendoza is Arkiv's testnet used during hackathons
const ARKIV_CHAIN = mendoza;

// Demo account for hackathon (from Arkiv docs)
// In production, users would sign with their own wallets
// For the hackathon, we use this shared testnet account
const DEMO_PRIVATE_KEY = '0x3d05798f7d11bb1c10b83fed8d3b4d76570c31cd66c8e0a8d8d991434c6d7a5e' as const;

// Credit Score structure stored in Arkiv
export interface ArkivCreditScore {
  address: Address;
  overall: number;
  breakdown: {
    loanHistory: number;
    liquidationAvoidance: number;
    portfolioDiversity: number;
    crossChainActivity: number;
  };
  timestamp: number;
  expiresAt: number;
}

/**
 * Calculate dynamic TTL based on score tier
 * - Score 300-500 (High Risk): 30 days
 * - Score 500-700 (Medium Risk): 60 days  
 * - Score 700+ (Low Risk): 90 days
 */
export function calculateDynamicTTL(score: number): ReturnType<typeof ExpirationTime.fromDays> {
  if (score < 500) {
    return ExpirationTime.fromDays(30); // High risk: shorter validity
  } else if (score < 700) {
    return ExpirationTime.fromDays(60); // Medium risk
  } else {
    return ExpirationTime.fromDays(90); // Low risk: longer validity
  }
}

/**
 * Get score tier label for display
 */
export function getScoreTier(score: number): string {
  if (score < 500) return 'High Risk';
  if (score < 700) return 'Medium Risk';
  return 'Low Risk';
}

/**
 * Get TTL in days based on score
 */
export function getTTLDays(score: number): number {
  if (score < 500) return 30;
  if (score < 700) return 60;
  return 90;
}

/**
 * Create Arkiv public client for reading data
 */
export function createArkivPublicClient() {
  return createPublicClient({
    chain: ARKIV_CHAIN,
    transport: http(),
  });
}

/**
 * Create Arkiv wallet client for hackathon demo
 * Uses a shared testnet account since Mendoza RPC restricts eth_sendTransaction
 * 
 * NOTE: In production, this would use user's wallet signature
 * For hackathon demo on testnet, we use shared demo account
 */
export function createArkivDemoWalletClient() {
  const account = privateKeyToAccount(DEMO_PRIVATE_KEY);
  
  return createWalletClient({
    chain: ARKIV_CHAIN,
    transport: http(),
    account,
  });
}

/**
 * Save credit score to Arkiv with dynamic TTL
 * 
 * NOTE: For hackathon demo, uses shared testnet account due to Mendoza RPC restrictions
 * In production, would use user's wallet for signing
 */
export async function saveCreditScoreToArkiv(
  userAddress: Address,
  score: ArkivCreditScore
) {
  const client = createArkivDemoWalletClient();
  
  const ttl = calculateDynamicTTL(score.overall);
  const ttlDays = getTTLDays(score.overall);
  
  // Add entityKey to score data for future reference
  const timestamp = Date.now();
  const expiresAt = timestamp + (ttlDays * 24 * 60 * 60 * 1000);
  
  const scoreWithTimestamps = {
    ...score,
    timestamp,
    expiresAt,
  };
  
  const { entityKey, txHash } = await client.createEntity({
    payload: jsonToPayload(scoreWithTimestamps),
    contentType: 'application/json',
    attributes: [
      { key: 'entity_type', value: 'credit_score' },
      { key: 'address', value: score.address.toLowerCase() },
      { key: 'score', value: score.overall.toString() },
      { key: 'tier', value: getScoreTier(score.overall) },
      { key: 'ttl_days', value: ttlDays.toString() },
    ],
    expiresIn: ttl,
  });

  // Note: entityKey is generated by Arkiv after creation
  // We return it so the frontend can store/display it
  return { entityKey, txHash, ttlDays, expiresAt };
}

/**
 * Get credit score from Arkiv by entity key
 */
export async function getCreditScoreFromArkiv(
  entityKey: `0x${string}`
): Promise<ArkivCreditScore | null> {
  const client = createArkivPublicClient();
  
  try {
    const entity = await client.getEntity(entityKey);
    
    if (!entity || !entity.payload) {
      return null;
    }

    // Parse payload (it's stored as bytes, needs decoding)
    const decoder = new TextDecoder();
    const payloadText = decoder.decode(entity.payload);
    const scoreData = JSON.parse(payloadText) as ArkivCreditScore;
    
    return scoreData;
  } catch (error) {
    console.error('Error fetching score from Arkiv:', error);
    return null;
  }
}

/**
 * Query credit scores by address
 */
export async function queryCreditScoresByAddress(
  address: Address
): Promise<ArkivCreditScore[]> {
  const client = createArkivPublicClient();
  
  try {
    const query = client.buildQuery();
    const result = await query
      .where({ type: 'eq', key: 'address', value: address.toLowerCase() })
      .where({ type: 'eq', key: 'entity_type', value: 'credit_score' })
      .withAttributes(true)
      .withPayload(true)
      .orderBy('timestamp', 'desc')
      .limit(10)
      .fetch();

    const scores: ArkivCreditScore[] = [];
    
    for (const entity of result.entities) {
      if (entity.payload) {
        const decoder = new TextDecoder();
        const payloadText = decoder.decode(entity.payload);
        const scoreData = JSON.parse(payloadText) as ArkivCreditScore;
        scores.push(scoreData);
      }
    }

    return scores;
  } catch (error) {
    console.error('Error querying scores from Arkiv:', error);
    return [];
  }
}

/**
 * Get the latest valid credit score for an address
 */
export async function getLatestCreditScore(
  address: Address
): Promise<{ score: ArkivCreditScore; entityKey: string; isValid: boolean } | null> {
  const scores = await queryCreditScoresByAddress(address);
  
  if (scores.length === 0) {
    return null;
  }

  const latestScore = scores[0];
  const now = Date.now();
  const isValid = now < latestScore.expiresAt;

  // Note: We don't have entityKey from query result directly
  // This would need to be stored in the score data or retrieved differently
  return {
    score: latestScore,
    entityKey: '', // TODO: Store entityKey in score data when saving
    isValid,
  };
}
